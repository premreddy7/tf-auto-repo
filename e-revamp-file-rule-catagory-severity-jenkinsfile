pipeline {
    agent {
        label 'win'  // Adjust to your Jenkins agent label
    }

    parameters {
        string(name: 'INPUTS', defaultValue: 'jenkins-project:main:2000-01-01,first_prj:main', description: 'Comma-separated list of project inputs in the format PROJECT_KEYS:BRANCH:DATE (DATE is optional)')
    }

    environment {
        SONAR_URL = "http://34.100.191.178:9000"  // Update to your SonarQube URL
        API_TOKEN = "squ_9aa34b2df5bb53ea7a6775655f430bf3c0810bb1"  // Replace with your actual API token stored in Jenkins
    }

    stages {
        stage('Fetch Data and Generate Report') {
            steps {
                script {
                    def allRules = [:]  // Store rule details (rule key to rule name mapping)
                    def page = 1
                    def totalRules = 0
                    def isLastPage = false

                    // Fetch all SonarQube rules using pagination
                    while (!isLastPage) {
                        def rulesUrl = "${env.SONAR_URL}/api/rules/search?ps=500&p=${page}"

                        bat(script: """
                            curl -s -u ${env.API_TOKEN}: "${rulesUrl}" -o rules_${page}.json
                        """)

                        if (fileExists("rules_${page}.json")) {
                            def rulesJson = readJSON file: "rules_${page}.json"
                            totalRules += rulesJson.rules.size()
                            isLastPage = rulesJson.paging.total <= totalRules
                            page++

                            // Store rule key to rule name mapping (without modification)
                            rulesJson.rules.each { rule ->
                                allRules[rule.key] = rule.name  // No replacement/manipulation of rule names
                            }
                        } else {
                            error "Failed to fetch rules from SonarQube at page ${page}"
                        }
                    }

                    def csvReport = new StringBuilder()
                    csvReport.append("From,project,branch,Categories,severity,filename,rulename,count\n")

                    def projectInputs = params.INPUTS.split(',')

                    projectInputs.each { input ->
                        def parts = input.split(':')
                        def projectKey = parts[0].trim()
                        def branch = parts[1].trim()
                        def date = parts.size() > 2 ? parts[2].trim() : null            

                        def issuePage = 1
                        def totalIssues = 0
                        def issuesLastPage = false
                        def issuesMap = [:]  // Map to store unique combinations

                        def issuesUrl = "${env.SONAR_URL}/api/issues/search?componentKeys=${projectKey}&branch=${branch}&statuses=OPEN&ps=500&p=${issuePage}"

                        if (date) {
                            issuesUrl += "&createdAfter=${date}"
                        }

                        // Fetch issues using pagination
                        while (!issuesLastPage) {
                            bat(script: """
                                curl -s -u ${env.API_TOKEN}: "${issuesUrl}" -o issues_${projectKey}_${issuePage}.json
                            """)

                            if (fileExists("issues_${projectKey}_${issuePage}.json")) {
                                def issuesJson = readJSON file: "issues_${projectKey}_${issuePage}.json"

                                totalIssues += issuesJson.issues.size()
                                issuesLastPage = totalIssues >= 10000 || issuesJson.paging.total <= totalIssues
                                issuePage++

                                issuesJson.issues.each { issue ->
                                    def component = issue.component
                                    def category = issue.type
                                    def severity = issue.severity.toLowerCase()
                                    def ruleKey = issue.rule

                                    // Fetch the exact rule name from the previously stored allRules
                                    def ruleName = allRules[ruleKey] ?: "Unknown Rule"

                                    // Create a unique issue key based on branch, category, severity, component, and rule name
                                    def issueKey = "${branch},${category},${severity},${component},${ruleName}"

                                    echo "Processing issue: ${issueKey}"

                                    // Match against existing keys in the issuesMap
                                    def foundMatch = false
                                    issuesMap.each { key, count ->
                                        // Check if the current key contains the relevant parts of the issueKey
                                        if (key.contains("${branch},${category},${severity},${component},")) {
                                            issuesMap[key] += 1
                                            echo "Duplicate found: ${issuesMap[key]} occurrences"
                                            foundMatch = true
                                        }
                                    }

                                    // If no match was found, add a new entry
                                    if (!foundMatch) {
                                        issuesMap[issueKey] = 1
                                    }
                                }
                            } else {
                                error "Failed to fetch issues for project ${projectKey} at page ${issuePage}"
                            }
                        }

                        // Debugging output to verify contents of issuesMap
                        echo "Issues Map Contents for ${projectKey}: ${issuesMap}"

                        // Append the unique entries with count to the CSV report
                        issuesMap.each { key, count ->
                            def keyParts = key.split(',')
                            csvReport.append("${date ?: 'N/A'},${projectKey},${keyParts[0]},${keyParts[1]},${keyParts[2]},${keyParts[3]},${keyParts[4]},${count}\n")
                        }
                    }

                    // Write CSV report to a file
                    writeFile file: 'SonarQube_Metrics_Report.csv', text: csvReport.toString()
                    archiveArtifacts artifacts: 'SonarQube_Metrics_Report.csv'
                }
            }
        }
    }
}
